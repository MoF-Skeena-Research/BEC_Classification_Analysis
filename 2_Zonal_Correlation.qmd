---
title: "ESSF Zonal Correlation Analysis"
author: "William H MacKenzie"
date: "`r format(Sys.Date(), '%d %B %Y')`"
format:
  typst:
    toc: true
    toc-depth: 2
    toc-title: Contents
    section-numbering: 1.1.1
    columns: 1
editor: source
execute:
  echo: false
  error: false
  warning: false
  message: false
  fig.width: 6
  fig.height: 4
  fig.align: 'left'
  fig.cap: true
  fig.pos: H
  out.width: '100%'
  dev: pdf
  fig.ext: pdf
  cache: false
  fig.retina: 2
  dpi: 600
  fig.asp: 1.5
  fig.path: "./figures/"
---


```{r setup, include=FALSE, echo=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE)
require(tidyverse)
require(DBI)
require(data.table)
require(cluster)
require(dendextend)
require(dynamicTreeCut)
require(gtable)
require(colorspace)
require(gtsummary)
require(openxlsx)
require(tictoc)
require(labdsv)
require(indicspecies)
require(Polychrome)
require(ggdendro)
require(purrr)
require(ggplotify)
require(grid)
set.seed(1279)
source("../BEC_R_working/_functions/_bec_dist.R")
source("../BEC_R_working/_functions/_bec_dist_matrix.R")
source("../BEC_R_working/_functions/_combine_taxa.R")
source("../BEC_R_working/_functions/_combine_taxa_strata.R")
source("../BEC_R_working/_functions/_create_su_vegdata.R")
source("../BEC_R_working/_functions/_create_analysis_vegsum.R")
source("../BEC_R_working/_functions/_TabletoTree.R")
source("../BEC_R_working/_functions/_TreetoTable.R")
source("../BEC_R_working/_functions/_add_vars.R")
source("../BEC_R_working/_functions/_do_pairwise.R")
source("../BEC_R_working/_functions/_create_diagnostic_veg.R")
source("../BEC_R_working/_functions/_return_similar_pairs.R")
source("../BEC_R_working/_functions/_read_sppmaster.R")
source("../BEC_R_working/_functions/_combined_su.R")
source("../BEC_R_working/_functions/_create_veg_sum.R")
source("./_functions/_create_veg_sum_all.R")
#source('../BEC_R_working/_functions/_create_veg_sum2.R')
source('../BEC_R_working/_functions/_build_species_ordering.R')
source('../BEC_R_working/_functions/_format_veg_table.R')
source('../BEC_R_working/_functions/_format_veg_table_strata.R')
source('../BEC_R_working/_functions/_encode_veg_sum.R')
source('../BEC_R_working/_functions/_create_dendro.R')
source('../BEC_R_working/_functions/_create_dendro_all.R')
source('../BEC_R_working/_functions/_create_dendro_bybgc.R')
source('../BEC_R_working/_functions/_draw_ss_edatope.R')
source('../BEC_R_working/_functions/_draw_dendro_split.R')
data.path = "D:/OneDrive - Government of BC/GitHub_data"
```

# Correlation of BGC zonal vegetation

Test of existing subzone variant groupings using BEC correlation process.

Need climate indicators and proper weighting of indicators vs non-indicators.

Works reasonably well in identifying lower groups but sometimes it seems like subzone group branches are mis-assigned to expected higher groupings. Generally the clustering matches the expected groupings when tree species and other key climate indicators are emphasized in the analysis.

Levels of differentiation of variants (subassociation level), subzones (association level), and zones are pretty good when tree subtaxa are used. Units often link up well into subzone groups though sometime these groups are 'misplaced'. The MS and SBPS as transitional zones are often linked to related subzone groups and not as a cohesive whole as expected.

Need to factor in USA 'zonal' ecosystems for cross-border correlation.

#### Read in data

Vegetation data is read in from saved .RDS file generated from the BECMaster cleaning scripts. Taxonomy is read-in from the species taxonomy database. A species lumping table is read-in from a Vpro database and applied to the vegetation data. The species taxonomy is joined to the vegetation data.

```{r load data, warning=FALSE, message=FALSE}
veg.dat <- readRDS(file.path(data.path, "BEC_veg_data/Analysis_BECMaster_Veg.rds")) ### named veg.dat
veg.dat2 <- veg.dat
taxon.all <- read_sppmaster()
taxon.lifeform <- taxon.all %>%
  filter(Codetype == "U" | Codetype == "X" | Codetype == "D") %>%
  dplyr::select(Code, ScientificName, EnglishName, Lifeform)# %>%
  # distinct() %>%
  # # manually add a row
  # add_row(Code = "FEATHERM", 
  #         ScientificName = "Feathermosses", 
  #         EnglishName = "Feathermosses", 
  #         Lifeform = 9)

 tree_seedlings <- taxon.lifeform %>% filter(Lifeform %in% c("1", "2")) %>% mutate(Code = paste0(Code, "D")) %>% pull(Code)
trees <- taxon.lifeform %>% filter(Lifeform %in% c("1", "2")) %>% pull(Code)
x <- veg.dat2 %>% filter(Species %in% "PSEUMEN1")
y = veg.dat2 %>% filter(PlotNumber %in% "PSEUMEN2")
veglump <- dbConnect(
  odbc::odbc(),
  .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; DBQ=D:/BC_Correlation2_Vpro_2023/Correlation2_Spp_lump.accdb;")
lump <- dbReadTable(veglump, "CorrelationII_Zonal_Lump") %>% filter(!LumpCode == "FEATHERM")
dbDisconnect(veglump)
veg.dat2 <- combine_taxa(vegdata = veg.dat2, lump, use.subtaxa = TRUE) %>% filter(!Species == "UNKNOWN")

bgc.units<- dbConnect(
  odbc::odbc(),
  .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; DBQ=D:/OneDrive - Government of BC/BECdb_Working/BECdb_ver13_2024.accdb;")
bgcv12 <- dbReadTable(bgc.units, "tblBGC_UnitsWorkingandArchive")
dbDisconnect(bgc.units)
bgcv13 <- bgcv12 %>% filter(is.na(VersionRetired)) %>% select(BGC_NoSpace, SiteClassificationStatus)
```

Project SU tables (e.g. BGC_SU for a LMH) are read-in from regional databases and combined into a project specific table. Then the zonal units are selected for the analysis.

```{r read in SU data}
db <- "D:/BC_Correlation2_Vpro_2023/published_sorts/CoastArea_Sorts.accdb"
su1 <- combined_su(db)
db <- "D:/OneDrive - Government of BC/Cariboo BEC Correlation/Cariboo_SU_2.accdb"
 su2 <- combined_su(db)
db <- "D:/BC_Correlation2_Vpro_2023/published_sorts/Cariboo_LMH39_Sorts.accdb"
su3 <- combined_su(db)
db <- "D:/BC_Correlation2_Vpro_2023/published_sorts/KootenayBoundary_Sorts.accdb"
su4 <- combined_su(db)
db <- "D:/BC_Correlation2_Vpro_2023/published_sorts/OminecaPeace_SU_Tables.accdb"
su5 <- combined_su(db)
db <- "D:/BC_Correlation2_Vpro_2023/published_sorts/Skeena_LMH26_Sorts.accdb"
su6 <- combined_su(db)
db <- "D:/BC_Correlation2_Vpro_2023/published_sorts/ThompsonOK_Sorts.accdb"
su7 <- combined_su(db)
db <- "D:/BC_Correlation2_Vpro_2023/published_sorts/LMH65_Boreal_Sorts.accdb"
su8 <- combined_su(db)
#db <- "D:/BC_Correlation2_Vpro_2023/Cassiar_SUs.accdb"
#su9 <- combined_su(db)
db <- "D:/OneDrive - Government of BC/LMH81_NorthColumbia_Review_Nov2025/NorthThompson_FG_draft.accdb"
#db <- "D:/BC_Correlation2_Vpro_2023/working/Lillooet_FG_draft.accdb"
su10 <- combined_su(db)
db <- "D:/OneDrive - Government of BC/LMH81_NorthColumbia_Review_Nov2025/Columbia_FG_draft.accdb"
#db <- "D:/BC_Correlation2_Vpro_2023/working/NorthThompson_FG_draft.accdb"
su11 <- combined_su(db)
db <- "D:/BC_Correlation2_Vpro_2023/working/Lillooet_FG_draft.accdb"
#db <- "D:/BC_Correlation2_Vpro_2023/working/NorthThompson_FG_draft.accdb"
su12 <- combined_su(db)
su <- rbind(su1, su2, su3, su4, su5, su6, su7, su8,  su10, su11, su12) %>% 
  filter(!grepl('moved', SiteUnit))
 #su <- rbind(su2,su10, su11) %>%
#   filter(!grepl('moved', SiteUnit))

# Identify duplicated PlotNumbers (both first and subsequent occurrences)
dups <- su[duplicated(su$PlotNumber) | duplicated(su$PlotNumber, fromLast = TRUE), ]


#xx <- su %>% filter(PlotNumber == "K780448")
su <- su %>%
  filter(!grepl('101a.2|101b.2|low|-S|add|nudum|poor|yc|_W|_F|ys|moved|X|support|Y', SiteUnit)) %>% distinct
fwrite(su, "./clean_data/combined_SU.csv")
#|
su <- su %>%   filter(grepl('01', SiteUnit)) ###zonal specific
su <- su %>% select(-SiteUnit.orig) %>% mutate(SiteUnit = str_replace(SiteUnit, "b$|a$|c$", "")) %>% distinct() %>% mutate(zone = str_extract(bgc, "([A-Z]+)"))
bgc.unique <- su %>% distinct(bgc) 
no.su <- anti_join(bgcv13, bgc.unique, by = c("BGC_NoSpace" = "bgc")) %>% filter(!SiteClassificationStatus == "none")
###write combined SU to database
# master_su <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)};
# DBQ=D:/BC_Correlation2_Vpro_2023/All_BC_Correlation.accdb;")
# dbWriteTable(master_su, "All_BC_zonals2_SU",  su, overwrite = TRUE, batch_rows = 1)
# dbDisconnect(master_su)
xx <- su %>% distinct(SiteUnit)
# su <- su %>%
# filter(!grepl('CWHvh3|CWHwh1|CWHwh2|CWHvh3|MHwh', SiteUnit))###BGC specific|CWHms

su <- su %>% filter(grepl('ESSF', SiteUnit))# %>%  mutate(bgc = ifelse(grepl('101.2', SiteUnit), paste0(bgc, "var2"), bgc))###BGC specific|CWHms
#su <- su %>% filter(grepl('ICH|IDFmw2|MS|SBS', SiteUnit)) #%>% 
  #filter(!grepl('ICHmm|ICHdm', SiteUnit))###BGC specific|CWHms
su <- su %>% mutate(SiteUnit = bgc)
## remove units that are not yet currently mapped zz is from the scripts clustering climate below
#su <- su %>% filter(!bgc %in% zz$.)

```

## Pairwise diagnostic analysis

Performed on base site units or hierarchical units. The function 'do_pairwise' applies a new similarity measure that balances the value of constancy and mean cover differences between units. This comparison starts with previously classification and reviewed site series as working units. Only species with high constancy in one of the units is used in the analysis. Key site indicators can be given higher importance The diagnostic value of non-vasculars is reduced but taxonomy exceptions can be assigned Returns a table of units with high similarity. Produce output table for review where units have low diagnostic potential (usually a function of heterogenous units in forest types) or high variability in plot membership

```{r build pair.wise, echo=FALSE, warning=FALSE, message=FALSE}
key.site.indicators <- c("CALLNOO","PICESIT","PSEUMEN2", 
                         #"ELLIPYR","GAULSHA", "VACCPAR", "PAXIMYR", "CLADPYR", 
                         # "STRUSPI", ## coast
                         # "ACERGLA", "GEOCLIV", "CALARUB",## interior
                         # "PICEGLA", "VACCVIT","MERTPAN",##boreal
                         #"RHODALB", "VALESIT", # ESSF
                         "TSUGMER","TSUGHET", "THUJPLI", "ABIEAMA", ##rain forest
                         "ABIEGRA", "PSEUMEN1","CALARUB", "PICEENE", "PINUCON",
                         "OPLOHOR", "GYMNDRY")
                         # "RHODALB", "MENZFER",   
                         
#, "MERTPAN", "VACCVIT", "BALSSAG")

### Try Lump codes for zonal indicators Coast vs Interior, then by CWH, MH, CDF for coast and Boreal (SBS, BWBS, SWB, SBPS, MS) Rainforest (ICH), Temperate (IDF, PP), Subalpine (ESSF)

#                          "PSEUMEN1","PSEUMEN2", "PICEENE", "ABIELAS", "ABIEGRA", "GYMNDRY", "OPLOHOR",, "VACCMEM"
#                           "PICEMAR", "LARIOCC", "ABIEAMA","PICEGLA","PINUCON1", "PINUCON2", "PINUPON")#,
                         # "RHODALB", "VACCOVL", "GAULSHA", "OPLOHOR",
                         # "CALARUB", "PSEUSPI",    "GYMNDRY"
                         #  ) 
#key.site.indicators <- taxon.all %>% filter(Lifeform %in% c(1,2)) %>% pull(Code)
reduced.exceptions <- c("SPHAGNUM", "CLADONIA", "CLADINA", "RACOMITR")#, "NEOORTHO", "FEATHERM")
#reduced.lifeforms <- c(3, 4, 5, 6, 7, 8, 9,10, 11, 12)
reduced.lifeforms <- c(9, 10, 11)
# reduced.lifeforms <- c(9,10)
 #bgc.choose = c('ESSFwh1', 'ESSFwh2', 'ESSFwh3','ESSFwh4', 'ESSFwh5',  'ESSFwh6', 'ESSFvm2', 'ESSFvm1')
  #bgc.choose = c('ESSFmw1', 'ESSFmw2')
bgc.list <- su %>% distinct(bgc) %>% pull(bgc)
su.reduced <- su %>% filter(bgc %in% bgc.list) 
#fwrite(su.reduced, "./outputs/combined_SU_zonal_ICH.csv")
vegsum.pairs <- do_pairwise(veg.dat2,
  su = su.reduced, minimportance = 0.1, minconstancy = 60,
  noiseconstancy = 10,
  minplots = 3,
  minor = 1,
  use.ksi = TRUE, ksi = key.site.indicators, ksi.value = 1.5,
  reduce.lifeform = TRUE, reduced.lifeforms = reduced.lifeforms, reduction = .2,
  reduced.exceptions = NULL
)

unit.sim <- vegsum.pairs %>%
  select(Unit1, Unit2, BEC.sim.min) %>% filter(BEC.sim.min >.80) %>% distinct#
  #filter(Unit1 == "ESSFmw1_01", Unit2 == "ESSFmw2_01")
yy <- vegsum.pairs %>% 
  select(Unit1, Unit2, Species, diagnostic.potential.x, diagnostic.potential.y, shared.diag, diff.pts.x, diff.pts.y, sum.shared.diag,diff.tot.x, diff.tot.y,  diff.ratio.x, diff.ratio.y, diff.ratio,BEC.sim.min, BEC.sim.mean) %>% 
  filter(Unit1== "SBSmz_101", Unit2 == "MSdc2_01")

vegsum.pairs <- vegsum.pairs %>% filter(!is.na(Unit1), !is.na(Unit2))
xx <- vegsum.pairs %>% filter(Unit1 == "ICHxm1_101")
units.low.diagnostics <- vegsum.pairs %>% 
  select(Unit1, unit.diag.sum.x) %>% 
  group_by(Unit1) %>%  mutate(diagnostic.sum = max(unit.diag.sum.x)) %>% select(-unit.diag.sum.x) %>% distinct %>%  filter(diagnostic.sum < 25) %>% ungroup()
gt::gt(units.low.diagnostics) %>% gt::fmt_number(decimals = 2)
```

```{r dist matrix, echo=FALSE, warning=FALSE, message=FALSE}
dis.matrix <- bec_dist_matrix(vegsum.pairs)
diss.table <- data.frame(SiteUnit = row.names(dis.matrix), dis.matrix)
fwrite(diss.table, "./outputs/example_dissimilarity_matrix.csv")
ss_clst <- agnes(dis.matrix,
  diss = TRUE, stand = TRUE,
  method = "average")
dendro_hc <- as.hclust(ss_clst)
# dend.dend <- as.dendrogram(dendro_hc)
### returns to cophonetic value - considered good if over 0.75
dend.dis <- as.dist(dis.matrix)
dend.co <- stats::cophenetic(dendro_hc)
cophonentic <- cor(dend.dis, dend.co) %>% data.frame %>% rename(cophonentic = ".")
gt::gt(cophonentic) %>% gt::fmt_number(decimals = 2) 
## measure of clusters alignment with the data; >0.7 is considered good
```

## Dendrogram of cluster analysis

```{r cluster analysis, echo=FALSE, warning=FALSE, message=FALSE}
#| label: fig-first-dendro
#| fig-cap: "Cluster analysis of zonal correlation units."
#| warning: false
#| fig-align: "center"
#| fig-width: 7
#| fig-height: 11
#| fig-dpi: 600
create_dendro_all(unit.compare = vegsum.pairs, cut.level = 0.2, method = "average", parameter = 1)

#bgc.unique <- c("CDFmm", "CWHvm3")
# for (bgc.choose in bgc.unique){
#   create_dendro_bybgc(bgc.choose, unit.compare)
# }
```

## Draw branch dendrograms

```{r split dendrogram, echo=FALSE}

xx <- draw_dendro_split(unit.compare = vegsum.pairs, cut.level=.2)
xx
```

```{r add cut level as group}
add_cluster_membership <- function(unit.compare, cut.level = .7){
  compared <- unit.compare 
  dis.matrix <- bec_dist_matrix(compared) 
  ss_clst <- agnes(dis.matrix,
                   diss = TRUE, stand = TRUE,
                   method = "average")
  dendro_hc <- as.hclust(ss_clst)
  groups <- cutree(dendro_hc, h = cut.level)
  SiteUnit <- rownames(dis.matrix)
  groups <- cbind(SiteUnit, groups) %>% data.frame() 
  # groups <- groups %>%  mutate(bgc = str_trim(str_extract(units, "([:upper:]|[:space:]){2,}"))) 
  return(groups)
  }

groups <- add_cluster_membership(vegsum.pairs, cut.level = .2)

xx <- vegsum.pairs %>% 
  filter(Unit1 %in% "ESSFxv2")#,

```

## Export summary table to excel

```{r build veg guide summary and export to excel, echo = FALSE, warning=FALSE, message=FALSE}
require(openxlsx)
require(tictoc)
library(stringr)
data.path = "D:/OneDrive - Government of BC/GitHub_data"
# tab.split = c('CDFmm_101', 'CDFmm_110', 'CDFmm_111', 'CDFmm_112',
#                  'CWHxm2_110', 'CWHxm2_111','CWHxm2_112.1','CWHxm2_112.2', 'CWHxm2_113')
author = "zonal_table1"
 # bgc.choose = c('ESSFwk1', 'ESSFwk2', 'ESSFvk', 'ESSFvc','ESSFwh4', 'ESSFwh5',  'ESSFwh6', 'ESSFvm2', 'ESSFvm1')
 #  bgc.choose = c('ESSFmw1', 'ESSFmw2')
bgc.choose <- bgc.list
su.zonal <- su
su.zonal <- su %>% filter(bgc %in% bgc.choose)
#bgc.list <- unique(su.zonal$bgc)

vegdata <- readRDS(file.path(data.path,"BEC_veg_data/Reports_BECMaster_Veg.rds"))
veg.dat2 <- combine_taxa_strata(vegdata = vegdata, lump, use.subtaxa = FALSE) %>% filter(!Species == "UNKNOWN")

#xx <- vegSum %>% filter(SiteUnit %in% c("ICHmk3", "ICHwk2"))
###table 1
# author = "zonal_table1"
# bgc.list = c("CDFmm", "CWHxm1", "CWHxm2", "CWHxm3", "CWHmm1", "CWHmm2", "CWHvm1", "CWHvm2")
author = "zonal_table3"
#bgc.list = c("CWHds1", "CWHds2", "CWHms1", "CWHms2", "CWHms3","CWHws1", "CWHws2", "CWHws3", "CWHxs", "IDFww1")
# author = "zonal_table3"
# bgc.list = c("CWHvh1", "CWHvh2",  "CWHvm3", "CWHvm4", "CWHwm", "MHmm1", "MHmm2", "MHws", "MHvh")

 # su.zonal <- su %>% filter(bgc %in% bgc.list) %>% mutate(SiteUnit = recode(SiteUnit, "CWHxm3" = "CWHdm3", "CWHxm2" = "CWHdm2", "CWHxm1" = "CWHdm1", "CWHms4" = "CWHws3", "MHws" = "MHms", "IDFww1"= "IDFww"))
# vegsum.wbk <- createWorkbook()
# vegSum <-
#   create_veg_sum_all(vdat = veg.dat2, siteUnits = su.zonal , minconstancy = 50, noiseconstancy = 25, strata.by = "Layer")
# ##determine order of species by unit
# # indic.order <- build_species_ordering(vdat = veg.dat2, vsum = vegSum,  siteUnits = su.zonal, BGC = bgc.choose)
# veg.sum.table <- format_veg_table_strata(vsum = vegSum, spp=taxon.lifeform)#, type = "zonal")
# openxlsx::addWorksheet(vegsum.wbk, sheetName = author)
# openxlsx::writeData(vegsum.wbk, sheet = author, veg.sum.table)
# 
# saveWorkbook(vegsum.wbk, paste0("./vegsum.tables/ESSF_zonal_tables_", author, ".xlsx"), overwrite = TRUE)


vegsum.wbk <- createWorkbook()

# Loop over each cluster
for (g in sort(unique(groups$groups))) {

  # SiteUnits in this group
  su_group <- groups %>% 
    filter(groups == g) %>% 
    pull(SiteUnit)

  # Filter your siteUnits table
  su_sub <- su.zonal %>% 
    filter(SiteUnit %in% su_group)

  # Build vegetation summary for this group
  vegSum_sub <- create_veg_sum_all(
    vdat = veg.dat2,
    siteUnits = su_sub,
    minconstancy = 50,
    noiseconstancy = 25,
    strata.by = "Layer"
  )

  # Format table
  veg.sum.table_sub <- format_veg_table_strata(
    vsum = vegSum_sub,
    spp = taxon.lifeform
  )

  # Name the sheet
  sheet_name <- paste0("Group_", g)

  # Add worksheet
  addWorksheet(vegsum.wbk, sheetName = sheet_name)

  # Write data
  writeData(vegsum.wbk, sheet = sheet_name, veg.sum.table_sub)
}

saveWorkbook(
  vegsum.wbk,
  paste0("./vegsum.tables/ESSF_zonal_tables_", author, ".xlsx"),
  overwrite = TRUE
)

```
## Generate formatted table summary report for BGC
Does not render to report only in interactive in RStudio

```{r}
# veg.sum.gt <- gt::gt(veg.sum.table) |> gt::tab_options(table.font.size = 8)|> gt::tab_style(
#     style = gt::cell_text(font = "Wingdings"),
#     locations = gt::cells_body(columns = 4:(ncol(veg.sum.table))-1, rows = 2:nrow(veg.sum.table))) |>
#   gt::tab_options(page.orientation = "landscape")|>
# gt::tab_style(
#     style = gt::cell_text(weight = "bold"),
#     locations = gt::cells_body(rows =1)) |>
#   gt::tab_header(
#       title = paste("ESSF_zonal_Summary Vegetation Table")
#   )
#  veg.sum.gt
```



```{r association sum table, echo=FALSE}
# symbolize_veg <- function(df) {
#   df[] <- lapply(df, function(col) {
#     if (!is.character(col)) return(col)
# 
#     col <- gsub("n", "\u25A0", col)  # black square
#     col <- gsub("v", "\u25A0", col)  # grey square (we recolor in Typst)
#     col <- gsub("l", "\u25CF", col)  # light grey circle
# 
#     col
#   })
#   df
# }
# 
# symbolize_veg_typst <- function(df) {
#   df[] <- lapply(df, function(col) {
#     if (!is.character(col)) return(col)
# 
#     col <- gsub("n", "#text(fill: black)[■]", col)
#     col <- gsub("v", "#text(fill: gray60)[■]", col)
#     col <- gsub("l", "#text(fill: gray80)[●]", col)
# 
#     col
#   })
#   df
# }
# 
# veg.sum.table.sym <- symbolize_veg_typst(veg.sum.table)
# 
# 
# 
# df_to_typst_table <- function(df, table_name = "vegtable") {
# 
#   escape <- function(x) {
#     x <- gsub("\\|", "\\\\|", x)
#     x <- gsub("#", "\\\\#", x)
#     x
#   }
# 
#   # Header
#   header <- paste(escape(names(df)), collapse = " | ")
# 
#   # Body rows
#   body_rows <- apply(df, 1, function(row) {
#     paste(escape(as.character(row)), collapse = " | ")
#   })
# 
#   # Build Typst table
#   typst <- c(
#     sprintf("#let %s = table(", table_name),
#     "  columns: auto,",
#     "  align: left,",
#     "  stroke: 0.5pt + gray80,",
#     "  header: true,",
#     "  [",
#     paste0("    ", header),
#     "  ],"
#   )
# 
#   # Add each row as its own bracketed block
#   for (r in body_rows) {
#     typst <- c(typst, "  [", paste0("    ", r), "  ],")
#   }
# 
#   # Close table
#   typst <- c(typst, ")")
# 
#   paste(typst, collapse = "\n")
# }
# 
# 
# typst_code <- df_to_typst_table(veg.sum.table.sym)
# writeLines(typst_code, "veg_sum_table.typ")


# bgc.list <- unique(su$bgc)
# for(bgc.choose in bgc.list){
# vegdata <- readRDS('./clean_data/Reports_BECMaster_Veg.rds')
# tree_seedlings <- taxon.lifeform %>% filter(Lifeform %in% c("1", "2")) %>% mutate(Code = paste0(Code, "D")) %>% pull(Code)
# trees <- taxon.lifeform %>% filter(Lifeform %in% c("1", "2")) %>% pull(Code)
# vegdata <- vegdata  %>% filter(!Species %in% tree_seedlings)
# vegdata <- vegdata  %>% filter(!(Species %in% trees & Layer == "Moss"))
# 
# veg.dat2 <- lump_species2(vegdata = vegdata, lump, use.subtaxa = FALSE)
# BGC <- "MHmm1"
# for(bgc.choose in bgc.unique){
#   vegSum <-
#   create_veg_sum(vdat = veg.dat2, siteUnits = su , BGC = bgc.choose, strata.by = "Layer")
# ##determine order of species by unit
# indic.order <- build_species_ordering(vdat = veg.dat2, vsum = vegSum, code.lump=lump, siteUnits = su, BGC = bgc.choose)
# veg.sum.table <- format_veg_table(vsum = vegSum, spp = taxon.lifeform)

# veg.sum.gt <- gt::gt(veg.sum.table) |> gt::tab_options(table.font.size = 8)|> gt::tab_style(
#     style = gt::cell_text(font = "Wingdings"),
#     locations = gt::cells_body(columns = 4:(ncol(veg.sum.table))-1, rows = 2:nrow(veg.sum.table))) |> 
#   gt::tab_options(page.orientation = "landscape")|>
# gt::tab_style(
#     style = gt::cell_text(weight = "bold"),
#     locations = gt::cells_body(rows =1)) |>
#   gt::tab_header(
#       title = paste("ESSF_zonal_Summary Vegetation Table")
#   )
#  veg.sum.gt
# veg.sum.gt2 <- gt::as_latex(veg.sum.gt)
# veg.sum.gt2

```

#```{=typst}
#import "veg_sum_table.typ": vegtable
#```

#```{=typst}
#vegtable
#```


## Review of BGCs

There are some 'mis-placed' BGC units from this analysis. The original designation of Zone membership is more rule based: first by leading tree species, some for practical or conceptual reasons, and with some use important secondary species or geographic distribution. MS separated from SBS as intermediate montane unit below ESSF above IDF or ICH SBPS separated from SBS northern ICH separate from CWH and southern ICH PP CWHvh as subzones rather than CCPH zone CDF separte from CWH.

Some individual unit issues: BWBSwk1 zonal plots are largely Pl leading due to a lack of older sample stands. For this reason does not match well with BWBS but closer to MS or SBPS

## Climate of zonal plots

```{r climate summaries}
# # plot.climr <- fread("./clean_data/plot_dat_climr.csv")
# # plot.climatena <- fread("./clean_data/plot_dat_climatena.csv")
# # zonal.climr <- left_join(su, plot.climr, by = c("PlotNumber" = "PlotNumber"))
# # zonal.climatena <- left_join(su, plot.climatena, by = c("PlotNumber" = "ID1"))
# # zonal.test <- zonal.climatena %>% filter(startsWith(bgc, "ICHx")) #%>% mutate(zone = ifelse(bgc %in% "ICHxm1", "NewICH", zone))
# # grid.climr <- fread("./clean_data/climr_WNAv13_5kmgrid.csv") %>% as.data.table %>% mutate(BGC = `_newBGC`) %>% select(-'_newBGC') %>% mutate(zone = str_trim(str_extract(BGC, "([:upper:]|[:space:]){2,}")))
# # fwrite(grid.climr, "./clean_data/climr_WNAv13_5kmgrid.csv")
# 
# grid.climr <- fread("./clean_data/climr_WNAv13_5kmgrid.csv") %>% as.data.table #%>% mutate(BGC = recode(BGC, "CWHdm" = "CWHxm3", "CWHms4" = "CWHws3", "MHws" = "MHms", "MHwsp" = "MHmsp"))
# #coast.climr<- fread("./clean_data/climr_coastv13_2_5kmgrid.csv")  %>%  mutate(zone = str_extract(BGC_2, "([A-Z]+)"))%>% as.data.table
# #xx <- unique(grid.climr$BGC) %>% data.frame() %>% rename(BGC = 1)
# #grid.climr[coast.climr, "BGC" := BGC_2, on = c("xcoord" = "xcoord", "ycoord" = "ycoord")]
#  
# #grid.test <- grid.climr   %>% filter(zone %in% c("CWH","IDF", "ICH")) %>% mutate(zone = ifelse(BGC %in% c("IDFww", "IDFww1", "IDFmw2", "ICHxm1", "ICHxw") , "NewICH", zone))
# grid.test <- grid.climr  %>% filter(BGC %in% bgc.choose)# %>% mutate(zone = str_trim(str_extract(BGC, "([:upper:]|[:space:]){2,}")
# 
# # grid.test <- grid.climr   %>% filter(zone %in% c("CDF", "CWH", "MH", "IDFww")) %>% mutate(zone = ifelse(BGC %in% c("CWHxm1", "CWHxm2", "CWHxm3") , "CWHdm-xm", zone)) %>%
# #   mutate(BGC = as.factor(BGC), zone = as.factor(zone)) #%>%
# # grid.test <- grid.climr   %>% filter(zone %in% c("CWH")) %>% mutate(zone = ifelse(BGC %in% c("CWHxm1", "CWHxm2", "CWHxm3") , "CWHdm-xm", zone)) %>%
# #   mutate(BGC = as.factor(BGC), zone = as.factor(zone)) #%>%
# 
# grid.test <- grid.test %>%  mutate(BGC = fct_reorder(BGC, MSP, .fun='median', .na_rm = T))
# 
# ggplot(grid.test, aes(x=BGC, y=MSP, colour = zone))+
#   geom_boxplot()+
#  #scale_colour_manual(values=c("darkgreen", "lightgreen", "orange", "red"))+
#   theme(legend.position = 'left')+ ggtitle("MSP for subzones coast guide")+
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size=8))
# 
# grid.test <- grid.test %>%  mutate(BGC = fct_reorder(BGC, CMD.total, .fun='median'))
# ggplot(grid.test, aes(x=BGC, y=CMD.total, colour = zone))+
#   geom_boxplot()#+
#  # scale_colour_manual(values=c("darkgreen", "lightgreen", "orange", "red"))+
#  #  theme(legend.position = 'left')+ ggtitle("CMD.total for subzones of CWH, ICH, & IDF with new ICH subzones from wet IDF")+
#  #  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size=8))
# 
# grid.test <- grid.test %>%  mutate(BGC = fct_reorder(BGC, MWMT, .fun='median'))
# 
# ggplot(grid.test, aes(x=BGC, y=MWMT, colour = zone))+
#   geom_boxplot()+
#  scale_colour_manual(values=c("darkgreen", "lightgreen", "orange", "red"))+
#   theme(legend.position = 'left')+ ggtitle("MWMT for subzones of CWH, ICH, & IDF with new ICH subzones from wet IDF")+
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size=8))
# 
# 
# 
# # grid.test <- grid.climr %>% mutate(zone = ifelse(BGC %in% c("IDFww", "IDFww1", "IDFmw2", "ICHxm1", "ICHxw") , "NewICH", zone)) %>% filter(zone %in% c("CWH","CDF", "ICH", "NewICH"))%>% 
# #   mutate(BGC = as.factor(BGC), zone = as.factor(zone)) %>%
# #   mutate(BGC = fct_reorder(BGC, TD, .fun='median', .na_rm = TRUE))
# grid.test <- grid.test %>%  mutate(BGC = fct_reorder(BGC, TD, .fun='median'))
# ggplot(grid.test, aes(x=BGC, y=TD, colour = zone))+
#   geom_boxplot()+
#  scale_colour_manual(values=c("darkgreen", "lightgreen", "orange", "red"))+
#   theme(legend.position = 'left')+ ggtitle("TD for subzones of CWH, ICH, & CDF with new ICH subzones from wet IDF")+
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, size=8))
# # zonal.test <- zonal.climr  %>% filter(zone %in% c("IDF", "ICH")) %>% mutate(zone = ifelse(startsWith(bgc, "IDFmw") , "NewICH", zone))
# # #order by CMD.total
# # zonal.test <- zonal.test %>% arrange(CMD.total)
# # ggplot(zonal.test, aes(x=BGC, y=CMD.total, colour = zone))+
# #   geom_boxplot()+
# #  # geom_smooth(method='lm')+
# #   theme(legend.position = 'left')+ ggtitle("Zonal Climate")

```

```{r zonal indicator species}
# SS <- su %>% left_join(groups) %>% 
#  mutate(zone = str_trim(str_extract(bgc, "([:upper:]|[:space:]){2,}"))) %>%
#       select(PlotNumber, groups) %>%
#     distinct()
# vegdata <- merge(veg.dat2, SS, by = "PlotNumber") %>% filter(!is.na(groups))
#   vegdata <- setDT(vegdata)[PlotNumber %in% SS$PlotNumber, ]
#   vegdata <- setDT(vegdata)[Species %in% vegsum.pairs$Species, ]
# 
#   veg_anal <- vegdata %>%
#     filter(Species %in% vegsum.pairs$Species) %>%
#     select(PlotNumber, Species, Cover) %>%
#     group_by(PlotNumber, Species) %>%
#     summarise(Cover = sum(Cover, na.rm = TRUE)) %>%
#     ungroup() %>%
#     data.frame() %>% arrange(PlotNumber)
#     veg_anal <- labdsv::matrify(veg_anal)
#     
#     groups2 <- SS %>% filter(PlotNumber %in% vegdata$PlotNumber) %>%
#       arrange(PlotNumber) %>% pull(groups)
# 
# indval <- indicspecies::multipatt(veg_anal, groups2,
#     control = how(nperm = 100)
#   )
#   summary(indval) 
# fwrite(indval, "./outputs/indval.csv")
#   
#    ## capture conditions where no species in a plot are in the selected vsum species
# veg.anal.plots <- rownames(veg_anal)%>% data.frame() %>% rename( PlotNumber= 1)
 
 
#    # veg.anal.plots$present <- "exists"
#    # missing <- left_join(SS, veg.anal.plots) %>% filter(is.na(present)) %>% select(PlotNumber)
#    groups <- SS %>% filter(PlotNumber %in% veg.anal.plots$PlotNumber) %>% distinct(PlotNumber, .keep_all = TRUE) %>% arrange(PlotNumber) %>%  pull(bgc)
#    # ss <- SS$SiteUnit
#    # n_units <- length(unique(vegsum.pairs$SiteUnit))
#    #   bgc <- vegdata $bgc
#
#


# zone <- rownames(dis.matrix) %>% data.frame() %>% rename(zone = 1) %>% mutate(zone = str_trim(str_extract(zone, "([:upper:]|[:space:]){2,}")))
# zone <- zone$zone
#
#   indval <- indicspecies::multipatt(dis.matrix, zone,
#     control = how(nperm = 9))

```

```{r subzone_group cluster, warning=FALSE}
# dend.veg <- dendro_hc %>% as.dendrogram 
# cut.ht <- 0.6
# cluster_grps <- cutreeHybrid(dendro_hc, distM = dis.matrix, cutHeight = cut.ht,
#                            minClusterSize = 2, deepSplit = 2)
# # cluster_grps <- cutreeDynamicTree(dendro_hc, maxTreeHeight = .1, minModuleSize = 2)
# 
# assocs <- cluster_grps$labelsassocs <- cluster_grps$labelsassocs <- cluster_grps$labels
# su_grps <- cbind(as.data.frame(assocs), as.data.frame(row.names(dis.matrix)))
# # we need to sort them to the order of the dendrogram:
# clusters <- assocs[order.dendrogram(dend.veg)]
# clusters_numbers <- unique(clusters)# - (0 %in% clusters)
# n_clusters <- length(clusters_numbers)
# 
# cols <- colorspace::rainbow_hcl(n_clusters)
# true_species_cols <- colorspace::rainbow_hcl(n_clusters)[as.numeric(assocs[order.dendrogram(dend.veg)])]
# # clusters <- factor(clusters)
# # levels(clusters)
```

## Dendrogram of cluster analysis

```{r subzonegroup dendro, warning=FALSE}
#| label: fig-subzonegrp-dendro
#| fig-cap: "Cluster analysis of zonal correlation units(.3 = subzone/groups)."
#| warning: false
#| fig-align: "center"
#| fig-width: 7
#| fig-height: 11
#| fig-dpi: 600

# dend.veg %>%
#       dendextend::color_branches(.,
#                                h = cut.ht,
#                                col = pals::trubetskoy(),
#                                groupLabels = TRUE) %>%
#   branches_attr_by_clusters(clusters, values = cols) %>%
#   color_labels(h = cut.ht, col = pals::trubetskoy()) %>%
#   set("labels_cex", .5) %>%
#   plot(horiz = TRUE)
```

```{r subzone dendro2, warning=FALSE}
#| label: fig-subzone-dendro
#| fig-cap: "Cluster analysis of zonal correlation units(.15 = Subzones)."
#| warning: false
#| fig-align: "center"
#| fig-width: 7
#| fig-height: 11
#| fig-dpi: 600

# dend %>%
#       dendextend::color_branches(.,
#                                h = cut.ht,
#                                col = pals::polychrome(),
#                                groupLabels = TRUE) %>%
#   branches_attr_by_clusters(clusters, values = cols) %>%
#   color_labels(h = cut.ht, col = pals::polychrome()) %>%
#   set("labels_cex", .5) %>%
#   plot(horiz = TRUE)
```

## Cluster Analysis of Climate Variables

```{r climate dendro, warning=FALSE}
#| label: fig-climate-dendro
#| fig-cap: "Cluster analysis of subzone climates"
#| warning: false
#| fig-align: "center"
#| fig-width: 7
#| fig-height: 11
#| fig-dpi: 600

# grid.climr <- fread("./clean_data/climr_WNAv13_5kmgrid.csv") %>% 
#   mutate(BGC = recode(BGC, "CWHdm" = "CWHxm3", "CWHms4" = "CWHws3")) %>% 
#   filter(BGC %in% su$bgc) %>% 
#   select(BGC, CMD.total, MWMT, TD, MSP, PAS) %>% 
#   drop_na() %>% group_by(BGC) %>% summarize_all(mean) %>% ungroup 
# 
# grid.climr <- grid.climr %>% column_to_rownames("BGC") %>% as.data.frame
# climr.matrix <- as.matrix(grid.climr) 
# climr.matrix <- scale(climr.matrix)
# clim.dist <- proxy::dist(climr.matrix) %>%  as.matrix %>% as.data.frame
# clim_clst <- agnes(clim.dist,
#   diss = TRUE, stand = TRUE,
#   method = "average")
# dendro_clim <- as.hclust(clim_clst)
# dend.clim <- dendro_clim %>% as.dendrogram 
# 
# 
# dend.clim %>%
#       dendextend::color_branches(.,
#                                h = cut.ht,
#                                col = pals::trubetskoy(),
#                                groupLabels = TRUE) %>%
#   #branches_attr_by_clusters(BGC, values = cols) %>%
#   color_labels(h = cut.ht, col = pals::trubetskoy()) %>%
#   set("labels_cex", .5) %>%
#   plot(horiz = TRUE)
```

### Double dendrogram between zonal and climate

```{r double dendrogram}
# require(dendextend)
# # dend.veg <- as.dendrogram(dendro_hc)
# # dend.clim <- as.dendrogram(dendro_clim)
# 
# qq <- rownames(dis.matrix) %>% as.data.frame; ww <- rownames(climr.matrix)%>% as.data.frame; zz <- anti_join(qq,ww) ###identify where classification have no mapped extent. Feed zz back into the filtering of the su at start of script if >0
# dl <- dendlist(dend.veg, dend.clim)
# tanglegram(dl, sort = TRUE, common_subtrees_color_lines = TRUE, highlight_distinct_edges  = TRUE, highlight_branches_lwd=FALSE, 
#            margin_inner=7,
#            lwd=2
# )#, common_subtrees_color_lines = FALSE, highlight_distinct_edges  = FALSE, highlight_branches_lwd = FALSE)
```

## Generate comparative veg summary report

```{r zonal table}
# su2 <- su %>% mutate(bgc = str_extract(SiteUnit, "[^_]+"))
# bgc.choose <- c("CWHxm1", "CWHvh1", "MHmm1")
# vegSum <- create_veg_sum(vdat = veg.dat2, siteUnits = su2 , BGC = bgc.choose)
# ##determine order of species by unit
# indic.order <- build_species_ordering(vdat = veg.dat2, vsum = vegSum, code.lump=lump, siteUnits = su2, BGC = bgc.choose)
# veg.sum.table <- format_veg_table2(vsum = vegSum, spp = taxon.lifeform)
# 
# gt::gt(veg.sum.table)
```
