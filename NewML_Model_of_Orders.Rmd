---
title: "MachineLearningHigherOrders"
author: "Will MacKenzie"
date: "06/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

require(tidyverse)
require(tidymodels)
require(data.table)
require(data.tree)
```

## A machine learning model of high-level hierarchical BEC units

```{r import clean data}
### Vegetation From BECMaster cleaning script Long form Plot|Species|Cover (across all layers)
### or From Vpro export
#####################importing Vpro veg data########################################
############### Uses 3 column R export FORMAT FROM Vpro with Lifeform option selected
load("./inputs/VegDat_Raw.RData")##includes type field for lifeform
vegDat2 <- vegData %>% filter(!is.na(Type))
###SU table
SUTab <- fread("./inputs/BECMster_V2020_2_SU.csv")
##Import Vpro hierarchy table widen and reformat
SUhier <- fread("./inputs/BECv12_Forests_July2020_Hierarchy.csv")

treeToTable <- function(SUhier){
  hierLookup <- SUhier[,.(ID,Name)]
  HierClean <- SUhier[,.(ID,Parent,Name,Level)]
  roots <- HierClean$Parent[!HierClean$Parent %in% HierClean$ID]
  roots <- unique(roots[!is.na(roots)])
  if(length(roots) >= 1){
    warning("There are duplicate roots. Please check ID ", roots)
  }
  HierClean[is.na(Parent), Parent := 1]
  temp <- data.table(ID = roots,Parent = rep(1,length(roots)), Name = rep("XXX",length(roots)),Level = rep(1, length(roots)))
  HierClean <- rbind(HierClean,temp)
  
  HierClean[hierLookup, ParentName := i.Name, on = c(Parent = "ID")]
  HierClean[is.na(ParentName), ParentName := "root2"]
  HierClean <- HierClean[,.(Name,ParentName,Level)]
  HierClean$ParentName[!HierClean$ParentName %in% HierClean$Name]
  tree <- FromDataFrameNetwork(HierClean)
  wideTab <- ToDataFrameTypeCol(tree)
  wideTab <- as.data.table(wideTab)
  wideTab[,ID := 1:nrow(wideTab)]
  wideTab[,level_1 := NULL]
  tab2 <- melt(wideTab, id.vars = "ID")
  tab2 <- na.omit(tab2)
  tab2[HierClean, Level := i.Level, on = c(value = "Name")]
  dupLevels <- tab2[,.(Len = .N), by = .(ID,Level)]
  dupLevels <- dupLevels[Len > 1,]
  dups <- tab2[ID %in% dupLevels$ID,]
  setorder(dups,"ID")
  dups[,variable := NULL] ##these are the branches with duplicates
  tabOut <- dcast(tab2, ID ~ Level, value.var = "value", fun.aggregate = function(x){x[1]})
  setnames(tabOut, c("ID","Region","Class","Order","Suborder","Alliance","Suball","Assoc","Subass","Working","SiteSeries"))
  tabOut[is.na(Subass), Subass := Assoc]
  tabOut[is.na(Suborder), Suborder := Order]
  tabOut[is.na(Suball), Suball := Alliance]
  return(list(table = tabOut, duplicates = dups))
}

temp <- treeToTable(SUhier)
hierWide <- temp$table
```


```{r summarize data, echo=FALSE}
BECHier <- fread("./inputs/AllForestHier_filled.csv")
### Summarize by SU including mean cover and constancy percent
##roll up into site series summary data

constCut <- 0 ##remove species less than cutoff
vegDat <- as.data.table(vegDat2)
vegDat[SUTab, SiteUnit := i.SiteUnit, on = "PlotNumber"]
vegDat <- vegDat[!is.na(SiteUnit) & SiteUnit != "",]
vegDat[,nPlots := .N, by = .(SiteUnit)]
vegSum <- vegDat[,.(MeanCov = sum(Cover)/nPlots[1], Constancy = (.N/nPlots[1])*100, nPlots = nPlots[1]), by = .(SiteUnit,Species)]
vegSum <- vegSum[Constancy >= constCut,]

```


```{r initial hierarchy placement}
#### Add all hierarchy unit to SS summary

```

```{r prep to build forest ML model}
### identify those SS that fall under the forest region
### ### add an 'X' pseudospecies to the site series summary where no trees occur
### Filter out all species but tree species

```

```{r build preliminary forest model}
###test and train

```

```{r review misassigned SS}

```

```{r predict placement of new SS and plots}

```

