---
title: "FieldGuide Summary Tables"
author: "Will MacKenzie"
date: "2024-08-12"
output: html_document
---

```{r setup, include=FALSE}
require(data.table)
require(tidyverse)
require(dplyr)
require(data.tree)
source("./_functions/_TreetoTable.R")
source("./_functions/_TabletoTree.R")
require(labdsv)
require(indicspecies)
```

#### Import becdb
```{r set folders, include=FALSE}
require(DBI) #loads odbc as well
 becdb <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; DBQ=D:/BECdb_Working/BECdb_ver12_2021_reduced.accdb;")

BGCs <- dbReadTable(becdb, "tblBGC_Units_v12") %>% select(BGC_label, BGC_NoSpace, BGC_Zone)
SiteSeries<- dbReadTable(becdb, "tblBEC_SiteSeries_v12_unique") %>% filter(Status == "Current") %>% select(BGC_NoSpace, SS_NoSpace, SS_Label)
dbDisconnect(becdb)
BGCs_noSS <- anti_join(BGCs , SiteSeries)

becdb <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; DBQ=D:/BECdb_Working/BECdb_ver12_2021_reduced.accdb;")
dbWriteTable(becdb, "BGCs_NoSS",  BGCs_noSS, overwrite = TRUE, batch_rows = 1)
dbDisconnect(becdb)
```

#### Import all BECMaster tables in /raw_data folder
```{r set folders, include=FALSE}
require(DBI) #loads odbc as well
 becmaster <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; DBQ=D:/GitHub/BECMaster_Cleaning/updated_vpro/BECMaster_fixing.accdb;")

ENV <- dbReadTable(becmaster, "BECMaster_fixing_Env") %>% mutate(Longitude = ifelse(Longitude<0, Longitude, 0-Longitude))
# ADMIN<- dbReadTable(becmaster, "BECMaster_fixing_Admin")
# VEG <- dbReadTable(becmaster, "BECMaster_fixing_Veg")
env.fields <- colnames(ENV)
odbc::odbcListColumns(becmaster, table = "BECMaster_fixing_ENV")
dbDisconnect(becmaster)

vegData <- readRDS('./clean_data/Reports_BECMaster_Veg.rds')
data.table::setDT(vegData)
# Lump Data
conL <- DBI::dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)};
DBQ=Vpro/CoastGuide_Spp_Lump.accdb;")
lump <- DBI::dbReadTable(conn = conL, name = 'CoastGuide2023_Lump')
data.table::setDT(lump)
species <- DBI::dbReadTable(conn = conL, name = 'SpeciesNames')
data.table::setDT(species)
lifeform <- species[ Codetype == 'U', .(ScientificName, Lifeform)] |> 
  unique()
species <- species[ Codetype == 'U', .(Code, EnglishName, ScientificName)] |> 
  unique()
rm(conL)
```

## Import site unit tables
```{r import SU tables and look for errors}
require(DBI) #loads odbc as well
correlation <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; 
DBQ=D:/BC_Correlation2_Vpro_2023/CoastGuide_Forested.accdb;")
all_su <- lapply(setNames(nm = (dbListTables(correlation)%>% str_subset("_SU"))), dbReadTable, conn = correlation)
dbDisconnect(correlation)
SU <- do.call(rbind.data.frame, all_su)
SU <- SU %>% mutate(bgc = substr(SiteUnit,1,9)) %>% mutate(bgc = str_replace_all(string=bgc, pattern=" ", repl=""), SiteUnit = str_replace_all(string=SiteUnit, pattern=" ", repl="") ) %>% drop_na() %>% distinct(PlotNumber, .keep_all = TRUE) %>% 
  arrange(desc(PlotNumber))
SU$SiteUnit <- str_replace(SU$SiteUnit, "[abc]$", "")
SU <- SU %>% filter(!str_detect(SiteUnit, '[$]|-poor|.nudum'), !startsWith(SiteUnit,'x'))
ss.unique <- SU %>% select(SiteUnit) %>% distinct
# SU2 <- SU %>% dplyr::select(PlotNumber, SiteUnit)
# 
# master_su <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; 
# DBQ=D:/BC_Correlation2_Vpro_2023/CoastGuide_Hierarchy.accdb;")
# dbWriteTable(master_su, "All_Coast_Forest_2024v4_SU",  SU2, overwrite = TRUE, batch_rows = 1, row.names = FALSE)
# dbDisconnect(master_su)

#%>% mutate(PlotNumber = paste0("'",PlotNumber))
#fwrite(SU, "./clean_tabs/CoastGuide_All_BGC_Forest_SU.csv")
###remove phases and seral units
# SU_siteseries <- SU %>% 
#   filter(!str_detect(SiteUnit, '[$]'))
# phases = c("a", "b", "c")
# SU_siteseries$SiteUnit <- str_replace(SU_siteseries$SiteUnit, "[abc]", "")
# fwrite(SU_siteseries, "./clean_tabs/CoastGuide_All_BGC_Forest_SS.csv")

# all_zonals <- SU2 %>% filter(str_detect(SiteUnit, "101|/01"))
# zonal_su <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; 
# DBQ=D:/BC_Correlation2_Vpro_2023/CoastGuide_Hierarchy.accdb;")
# dbWriteTable(zonal_su, "Coast_Zonals_SU", all_zonals, overwrite = TRUE, batch_rows = 1, row.names = FALSE)
# dbDisconnect(zonal_su)

```
## functions to build BGC veg summary table
```{r build summary}
source('./_functions/functions.R')
source('./_functions/_lump_species2.R')
vdat <- readRDS('./clean_data/Reports_BECMaster_Veg.rds')
data.table::setDT(vdat)
create_veg_sum <- function(vdat, siteUnits, minconstancy = 60, noiseconstancy = 20, BGC) {
    vdat <- lump_species2(vdat, lump=lump) 
  vdat <- merge(vdat, siteUnits, by = 'PlotNumber')
  vdat <- vdat[PlotNumber %in% siteUnits$PlotNumber, ]
  #vdat <- vdat %>% filter(bgc %in% BGC)
  vdat <- vdat[bgc %in% BGC, ]

 vdat <- vdat[,if(.N > 1) .SD, by = .(SiteUnit,Species)]
  vdat[ , nplots := length(unique(PlotNumber)), by = .(SiteUnit)]
  vdat <- vdat[,.(
    MeanCov = sum(Cover, na.rm = TRUE) / unique(nplots), # should this just be mean, is NA assumed to be 0?
    Constancy = (.N / unique(nplots)) * 100, 
    nplots = unique(nplots)
#  ), by = .(SiteUnit, Species, Lifeform)]
  ), by = .(SiteUnit, Species, Layer)]
vdat[ , maxcons := max(Constancy), by = .(Species)]
vdat <- vdat[maxcons > minconstancy, ]
vdat <- vdat[Constancy > noiseconstancy, ]
}

encode_veg_sum <- function(coverage, constancy) {
  black <- 'n'
  grey <- 'l'
  star <- 'v'
  char <- black
  if (constancy < 80) {
    char <- grey
  } 
  if (constancy <= 60) {
    char <- star
  }
 color = "remove"
  code <- data.table::fcase(
    coverage <   1,
    sprintf('%s-%s', paste0(rep(char, 1), collapse=''), color),
    coverage <   3,
    sprintf('%s-%s', paste0(rep(char, 2), collapse=''), color),
    coverage <  10,
    sprintf('%s-%s', paste0(rep(char, 3), collapse=''), color),
    coverage <  25,
    sprintf('%s-%s', paste0(rep(char, 4), collapse=''), color),
    coverage < 100,
    sprintf('%s-%s', paste0(rep(char, 5), collapse=''), color),
    default = paste0(rep(char, 6), collapse='')
  )
}

build_species_ordering <- function(vdat, vsum = vegSum, code.lump = lump, siteUnits, BGC){
  vegdata <- lump_species2(vdat, code.lump) 
  vegdata <- merge(vegdata, siteUnits, by = 'PlotNumber')
  vegdata <- vegdata[PlotNumber %in% siteUnits$PlotNumber, ]
  #vegData <- vegData %>% filter(bgc %in% BGC)
  vegdata <- vegdata[bgc %in% BGC, ] %>% data.frame
  SS <- vegdata %>% select(PlotNumber, SiteUnit) %>% distinct
  SS <- SS$SiteUnit
veg_anal <- vegdata %>% filter(Species %in% vsum$Species) %>% select(PlotNumber, Species,Cover) %>% group_by(PlotNumber, Species) %>% summarise(Cover = sum(Cover, na.rm = TRUE)) %>% ungroup() %>%  data.frame()
veg_anal <- matrify(veg_anal)


n_units <- length(unique(vsum$SiteUnit))
indval <- indicspecies::multipatt(veg_anal, SS, 
                    control = how(nperm=9)) 
#summary(indval, alpha=1)
indic.order <- indval$str %>% data.frame  %>% select(1:(all_of(n_units))) %>% rownames_to_column("spp") %>%  pivot_longer(-spp, names_to = "siteunit", values_to = "indic") %>% group_by(spp) %>% mutate(max_indic = max(indic)) %>% filter(indic == max_indic) %>% ungroup() %>% left_join(species, by=c(spp = 'Code')) %>%  arrange(desc(indic)) %>%  mutate(siteunit = str_replace(siteunit, "101", "109")) %>% arrange(siteunit)

}

format_veg_table <- function(vsum = vegSum, spp = species){
  #create new variable Species2 in vegSum from Species and Layer
  vsum$Species2 <- paste0(vsum$Species, "_", vsum$Layer)
  vsum[ , code := encode_veg_sum(MeanCov, Constancy), by = .(Species2, SiteUnit)]
  vsum <- vsum %>% merge(spp, by.x = 'Species', by.y = 'Code') |>
  mutate(SiteUnit = str_replace(SiteUnit, "101", "109"))
  #merge(spp, by.x = 'Species', by.y = 'Code') |>
  #mutate(SiteUnit = str_replace(SiteUnit, "101", "109"))
  nPlots <- unique(vsum[ ,.(SiteUnit, nplots)])[order(nplots, decreasing = TRUE), ] %>% 
    arrange(SiteUnit)
  vsum <- data.table::dcast(vsum, 
    Layer + ScientificName + EnglishName ~ SiteUnit, 
    value.var = 'code',
    fill = '')[order(Layer, ScientificName), ]
  #vsum[duplicated(ReportName, fromLast = TRUE), ReportName := '']
 vsum[ , c('Layer','ScientificName', nPlots$SiteUnit, 'EnglishName'), with = FALSE]
  data.table::setnames(vsum, old = c('Layer', 'ScientificName', 
    'EnglishName'), new = c('Layer', 'Scientific name', 'Common name'))
vsum <- vsum %>% 
  mutate_all(str_replace_all,"-remove", "")
     # vsum$Layer <-  case_match(vsum$Layer, "1" ~ "A",
     #                            "2" ~ "A",
     #                            "3" ~ "B",
     #                            "4" ~ "B",
     #                            "5" ~ "C",
     #                            "6" ~ "C" ,
     #                            "7" ~ "C",
     #                            "8" ~ "C",
     #                            "9" ~ "D",
     #                           "10" ~ "D",
     #                           "11" ~ "D",
     #                           "12" ~ "C")
  vsum <- vsum[ order(match(vsum$Scientific, indic.order$ScientificName)), ]
  
  vsum2 <-   vsum %>% select(order(colnames(vsum))) %>%  
    left_join(lifeform, by = c("Scientific name" = "ScientificName")) %>% 
    mutate(Layer = ifelse((Layer == "Shrub" & Lifeform %in% c(1,2)), "Regen", Layer)) %>% select(Layer, `Scientific name`, everything()) %>% select(-Lifeform) %>% 
    relocate(`Common name`, .after = last_col()) %>%
    arrange(match(Layer, c("Tree", "Regen", "Shrub", "Herb", "Moss")), Layer)

  colnames(vsum2) <- gsub("/109", "/101", colnames(vsum2))
    colnames(vsum2) <- gsub(paste0(bgc.choose,"/"), "", colnames(vsum2))
   nPlotRow <- c('', 'n Plots', nPlots$nplots, '') |> 
    matrix(nrow = 1) |>
    data.frame() |> 
    stats::setNames(names(vsum2)) |> 
    data.table::as.data.table()
  vsum3 <- rbind(nPlotRow, vsum2)
}
```

This can take some time since indicspecies for determining the order of species is a very slow package
```{r build veg guide summary and export to excel, warning=FALSE}
require(openxlsx)
require(tictoc)
bgc.list <- unique(SU$bgc)
###Dels
bgc.list = c("CDFmm", "CWHds2", "CWHmm1", "CWHmm2", "CWHws1", "CWHws2",
"CWHws3", "CWHxm1", "CWHxm2", "CWHxm3", "IDFww1")
### Bobs
bgc.list = c("CWHds1", "CWHms1", "CWHms2", "CWHms3", "MHmm1",
"MHmm2", "MHws", "MHvh")
### Allen's
# bgc.list = c("CWHvh1", "CWHvh2", "CWHvm1", "CWHvm2", "CWHvm3",
# "CWHvm4", "CWHwm")
#bgc.list = c("CDFmm")
SU <- SU %>% arrange(bgc)
#bgc.choose = "CDFmm"
vegsum.wbk <- createWorkbook()
tic()
for(bgc.choose in bgc.list){
vegSum <- 
  create_veg_sum(vdat = vegData, siteUnits = SU , BGC = bgc.choose)
##determine order of species by unit
indic.order <- build_species_ordering(vdat = vegData, vsum = vegSum, code.lump=lump, siteUnits = SU, BGC = bgc.choose)
veg.sum.table <- format_veg_table(vsum = vegSum)
openxlsx::addWorksheet(vegsum.wbk, sheetName = bgc.choose)
openxlsx::writeData(vegsum.wbk, sheet = bgc.choose, veg.sum.table) 
}
toc()
saveWorkbook(vegsum.wbk, "./vegsum.tables/LMH77_draft_veg_tables-BG.xlsx", overwrite = TRUE)


# vegsum.wbk <- XLConnect::loadWorkbook("./vegsum.tables/XLConnect.xlsx", create = TRUE)
# tic()
# for(bgc.choose in bgc.list){
# vegSum <- 
#   create_veg_sum(vdat = vegData, siteUnits = SU ,BGC = bgc.choose)
# ##determine order of species by unit
# indic.order <- build_species_ordering(vdat = vegData, vsum = vegSum, code.lump=lump, siteUnits = SU, BGC = bgc.choose)
# veg.sum.table <- format_veg_table(vsum = vegSum)
# XLConnect::createSheet(vegsum.wbk, name = bgc.choose)
# XLConnect::createName(vegsum.wbk, name = bgc.choose)
# XLConnect::writeNamedRegion(vegsum.wbk, region = bgc.choose, data = veg.sum.table)
# XLConnect::file.remove("XLConnect.xlsx")
# #openxlsx::writeData(vegsum.wbk, sheet = bgc.choose, veg.sum.table) 
# }
# toc()
# XLConnect::saveWorkbook(vegsum.wbk, "./vegsum.tables/LMH77_draft_veg_tables2.xlsx", overwrite = TRUE)

```



