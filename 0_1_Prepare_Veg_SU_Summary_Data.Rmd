---
title: "Check SUs and prepare summarized vegetation data by site units"
author: "Will MacKenzie"
date: "13/09/2021"
output: html_document
---

```{r setup, include=FALSE}
require(data.table)
require(tidyverse)
require(dplyr)
require(data.tree)
require(DBI) #loads odbc as well
require(labdsv)
require(factoextra)
source("./_functions/_TreetoTable.R")
source("./_functions/_TabletoTree.R")
```

#### Import all raw vpro tables in /raw_data folder
```{r set folders, include=FALSE}
load("./clean_data/veg_plot_data.RData")

becmaster <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; DBQ=D:/BECMaster19/BECMaster19.accdb;")
ENV <- dbReadTable(becmaster, "BECMaster19_Env") %>% mutate(Longitude = ifelse(Longitude<0, Longitude, 0-Longitude))
ADMIN<- dbReadTable(becmaster, "BECMaster19_Admin")
env.fields <- colnames(ENV)
odbc::odbcListColumns(becmaster, table = "BECMaster19_ENV")
dbDisconnect(becmaster)
```


## Import SU table and BECdb for current BGC units and site series. Look for missing units. Create complete SU 

```{r import SU tables and look for errors}
require(DBI) #loads odbc as well
correlation <- dbConnect(odbc::odbc(), .connection_string = "Driver={Microsoft Access Driver (*.mdb, *.accdb)}; DBQ=D:/BC_Correlation2_Vpro_2023/CoastGuide_Forested.accdb;")
all_su <- lapply(setNames(nm = (dbListTables(correlation)%>% str_subset("_SU"))), dbReadTable, conn = correlation)
dbDisconnect(correlation)
SU <- do.call(rbind.data.frame, all_su)
SU <- SU %>% mutate(bgc = substr(SiteUnit,1,9)) %>% drop_na() %>% distinct()
fwrite(SU, "./clean_tabs/CoastGuide_All_BGC_Forest_SU.csv")
###remove phases and seral units
SU_siteseries <- SU %>% 
  filter(!str_detect(SiteUnit, '[$]'))
phases = c("a", "b", "c")
SU_siteseries$SiteUnit <- str_replace(SU_siteseries$SiteUnit, "[abc]", "")
fwrite(SU_siteseries, "./clean_tabs/CoastGuide_All_BGC_Forest_SS.csv")

SU <- SU_siteseries
###Check that there is plot data for all
missingplots <- anti_join(SU, ENV)
plots <- right_join(SU, ENV)
### Check for duplicate plot usage
usemorethanone <- SU %>% dplyr::group_by(PlotNumber) %>% dplyr::mutate(dups = n()) %>% filter(dups >1) %>% ungroup() %>% arrange(PlotNumber)
fwrite(usemorethanone, "./outputs/Coast_Plots_Used_Morethan_Once.csv")
###Summaries by BGC and by SS
plots_bgc <- SU %>% group_by(bgc) %>% dplyr::summarise(plots = n())
plots_SS <- SU %>% group_by(SiteUnit) %>% dplyr::summarise(plots = n())
SS_count <- length(unique(SU$SiteUnit))
siteunits_toofew <- plots_SS %>% filter(plots <5) #%>% dplyr::select(- PlotNumber) %>% distinct

fwrite(siteunits_toofew, "./outputs/Coast_SiteUnits_w_lessthan5plots.csv")
```

##roll up into site series summary data and reduce to analysis set
```{r summarize site series, echo=FALSE}
### test run without non-vasculars
vegdata <- vegdata %>% filter(lifeform <9 | lifeform == 12)
#vegdata <- vegdata %>% filter(lifeform <3)
source("./_functions/_create_su_vegdata.R")
vegsum <- create_su_vegdata(vegdata, SU)

source("./_functions/_create_analysis_vegsum.R")
veg_anal <- create_analysis_vegsum (vegsum, importance = 0.5, constancy = 60, minplots = 5) 
SS_reduced_list <- unique(veg_anal$SiteUnit)
SU_reduced <- SU %>% filter(SiteUnit %in% SS_reduced_list)
```

Cluster of site units to create associations.
Uses the reduced species set and sets an  distance cut-off that seems to equate to association
Need to test against the pairwise routine.

```{r create distance matrix}
require(harrietr)
veg.dat <-
  veg_anal %>% dplyr::select(SiteUnit, Species, spp_importance) %>% matrify()
# test_jac.vegan <- vegan::vegdist(test.data, method = "sorensen", binary = F) %>% as.matrix
#test_jac <- philentropy::distance(test.data, method = "jaccard")
test_jac <- proxy::dist(veg.dat, method="ejaccard", diag=TRUE, upper = FALSE) ## ejaccard and philentropy jaccard are real-data versions extended jaccard opr taimoto
# xx <- as.matrix(test_jac)
# units <- as.data.frame(rownames(xx))

# , use.row.names = TRUE, as.dist.obj = TRUE)
test_jac.tab <- test_jac %>% as.matrix
test_jac.list <- harrietr::melt_dist(test_jac.tab) %>% as.data.table #%>% filter(dist < .25)
fwrite(test_jac.tab, "./outputs/dissimtest.csv")
fwrite(test_jac.list, "./outputs/dissim_pairwise.csv")
```

Use agnes algorithms to build bottom-up hierarchy. Cutting the dendrogram at a low dissimilarity threshold (0.25) seems to make good working groups that pass the second pair-wise test. However, the structure of the higher level groups seems odd in some cases where similar site series end up in very different upper units.
Might need to develop an alternative grouping mechanism
```{r cluster and cut - standard algorithms}
#ss_clst <- hclust(test_jac, method = "complete")
library(cluster)
ss_clst = agnes(test_jac, diss = TRUE, stand = FALSE,
      method = "complete")
ht_dendro <- max(ss_clst$height)*.999
dendro_test =as.dendrogram(ss_clst)
plot(dendro_test)

par(mfrow=c(3,1))

plot(dendro_test, main="Main")
plot(cut(dendro_test, h = ht_dendro)$upper,
     main="Upper tree of cut at h=75")
plot(cut(dendro_test, h = ht_dendro)$lower[[4]],
     main="Second branch of lower tree with cut at h=75")

 orders <- cutree(as.hclust(ss_clst), h=ht_dendro)
 order_SU <- as.data.frame(orders) %>% rownames_to_column("SiteUnit")# %>% mutate(orders = paste0("order-", orders))
 order_SU <- left_join(SU, order_SU, by = "SiteUnit")
 fwrite(order_SU, "./outputs/orders_SU.csv")
```
The cut-offs representing each level are approximate. Really only the lowest level c
```{r cut cluster }
 working <- cutree(as.hclust(ss_clst),h =.25)
alliances <- cutree(as.hclust(ss_clst), h=.5)
 suborders <- cutree(as.hclust(ss_clst), h=.75)
 orders <- cutree(as.hclust(ss_clst), h=.999)
# k = length(unique(working))
# k2 <- length(unique(alliances))
# k3 <- length(unique(suborders))
# k4 <- length(unique(orders))
# ss_dend <- fviz_dend (ss_clst , k=k4, color_labels_by_k = T, lwd = .5, rect = T, cex = .5, horiz = T) %>%    plot()
  # 
working_SU <- as.data.frame(working) %>% rownames_to_column("SiteUnit") %>% mutate(working = paste0("workgrp-", working))
working_SS <- left_join(SU, working_SU, by = "SiteUnit") %>% select (SiteUnit, working) %>% distinct %>% drop_na
# %>% arrange(desc(PlotNumber))
alliance_SU <- as.data.frame(alliances) %>% rownames_to_column("SiteUnit") %>% mutate(alliances = paste0("alliance-", alliances))
suborder_SU <- as.data.frame(suborders) %>% rownames_to_column("SiteUnit") %>% mutate(suborders = paste0("suborder-", suborders))
newsuborder <- unique(suborder_SU$suborders)
order_SU <- as.data.frame(orders) %>% rownames_to_column("SiteUnit") %>% mutate(orders = paste0("order-", orders))
#order_SU <- order_SU %>% mutate(orders = ifelse((orders %in% fewplots$x), "Unplaced", orders))
#neworder <- unique(order_SU$orders)

Hier_SU <- left_join(SU, working_SU, by = "SiteUnit") %>% 
left_join(alliance_SU, by = "SiteUnit") %>% 
  left_join(suborder_SU, by = "SiteUnit") %>% 
  left_join(order_SU, by = "SiteUnit") %>% distinct() %>% drop_na()

fwrite(Hier_SU, "./outputs/CoastForestClusteredUnits_SU.csv")
```

Build a Vpro hierachy style to be copied into a copy of the sample hier and then save as to a real hierarchy where the ID can be turned back into an autonumber for proper working of Vpro hierarchy functions

```{r Convert to hierarchy}
Hier.new <- Hier_SU %>% mutate(formation = "-", class = "-", suball = "-", subass = "-", facies = "-", assocs = "-") %>%   
  select(formation, class, orders, suborders,alliances, suball, assocs, subass, facies, working, SiteUnit) %>% 
  distinct()
Hier.new  <- Hier.new  %>% mutate(class = ifelse(is.na(working), "unplaced", "placed" ))
#Hier.new <- fread("./outputs/BECv13_Hierarchy_Matrix.csv")
 levelNames <- c("formation", "class", "orders", "suborders", "alliances", "suball", "assocs", "subass", "facies", "working", "SiteUnit")
Hier.new <- as.data.table(Hier.new)
testReverse <- tableToTree(hierWide = copy(Hier.new),levelNames)
testReverse$Parent <- ifelse(testReverse$Parent == 1, "", testReverse$Parent)
fwrite(testReverse, "./outputs/CoastForestHierarchyTree.csv")
```

####______________SOME OTHER TESTS_______________________

Build assocs in two steps. Build an initial very similar set and then cluster the initial cluster again
```{r cutree}

 assocs <- cutree(as.hclust(ss_clst),h =.25)
 assoc_SU <- as.data.frame(assocs) %>% rownames_to_column("SiteUnit") %>% mutate(assocs = paste0("working-", assocs))
assoc_SS <- left_join(SU_reduced, assoc_SU, by = "SiteUnit") %>% select (SiteUnit, assocs) %>% distinct %>% drop_na
count_assocs <- length(unique(assoc_SS$assocs))
```
Repeat cluster with first round working and look for similar

```{r rebuild the hierarchy using the new assoc as the root}
SU2 <- left_join(SU_reduced, assoc_SU) %>% rename(siteseries = SiteUnit, SiteUnit = assocs)

source("./_functions/_create_su_vegdata.R")
vegsum <- create_su_vegdata(vegdata, SU2)

source("./_functions/_create_analysis_vegsum.R")
veg_anal <- create_analysis_vegsum (vegsum, importance = 0.5, constancy = 60, minplots = 5)

veg.dat <-
  veg_anal %>% dplyr::select(SiteUnit, Species, spp_importance) %>% matrify()
# test_jac.vegan <- vegan::vegdist(test.data, method = "sorensen", binary = F) %>% as.matrix
#test_jac <- philentropy::distance(test.data, method = "jaccard")
test_jac <- proxy::dist(veg.dat, method="ejaccard", diag=TRUE, upper = TRUE)
ss_clst2 = agnes(test_jac, diss = TRUE, stand = FALSE,
      method = "complete")
 assocs2 <- cutree(as.hclust(ss_clst2),h =.25)
 assoc_SS2 <- as.data.frame(assocs2) %>% rownames_to_column("SiteUnit") %>% mutate(assocs2 = paste0("assoc-", assocs2)) %>% rename(assocs = SiteUnit)
 assoc_SU2 <- left_join(assoc_SU, assoc_SS2, by = "assocs")
 SU3 <- SU2 %>% rename(assocs = SiteUnit, SiteUnit = siteseries) %>% select(-assocs)
assoc_SU2 <- left_join(SU3, assoc_SU2, by = "SiteUnit") %>% select (PlotNumber, SiteUnit, assocs, assocs2) %>% rename(working = assocs, assocs = assocs2) %>% distinct %>% drop_na
assoc_SS2 <- assoc_SU2 %>% select (-PlotNumber) %>% distinct %>% drop_na
count_assocs2 <- length(unique(assoc_SS2$assocs))

# working <- cutree(as.hclust(ss_clst),h =.25)
alliances <- cutree(as.hclust(ss_clst), h=.5)
 suborders <- cutree(as.hclust(ss_clst), h=.80)
 orders <- cutree(as.hclust(ss_clst), h=.995)
  # 
alliance_SU <- as.data.frame(alliances) %>% rownames_to_column("SiteUnit") %>% mutate(alliances = paste0("alliance-", alliances))
suborder_SU <- as.data.frame(suborders) %>% rownames_to_column("SiteUnit") %>% mutate(suborders = paste0("suborder-", suborders))
newsuborder <- unique(suborder_SU$suborders)
order_SU <- as.data.frame(orders) %>% rownames_to_column("SiteUnit") %>% mutate(orders = paste0("order-", orders))
#order_SU <- order_SU %>% mutate(orders = ifelse((orders %in% fewplots$x), "Unplaced", orders))
#neworder <- unique(order_SU$orders)

Hier_SU <- left_join(assoc_SU2, alliance_SU, by = "SiteUnit") %>% 
  left_join(suborder_SU, by = "SiteUnit") %>% 
  left_join(order_SU, by = "SiteUnit") %>% distinct() %>% drop_na()

fwrite(Hier_SU, "./outputs/CoastForest2stepClusteredUnits_SU.csv")
```

```{r rebuild the hierarchy using the new assoc as the root}
Hier.new <- Hier_SU %>% mutate(formation = "-", class = "-", suball = "-", subass = "-", facies = "-") %>%   
  select(formation, class, orders, suborders,alliances, suball, assocs, subass, facies, working, SiteUnit) %>% 
  distinct()
Hier.new  <- Hier.new  %>% mutate(class = ifelse(is.na(working), "unplaced", "placed" ))
#Hier.new <- fread("./outputs/BECv13_Hierarchy_Matrix.csv")
 levelNames <- c("formation", "class", "orders", "suborders", "alliances", "suball", "assocs", "subass", "facies", "working", "SiteUnit")
Hier.new <- as.data.table(Hier.new)
testReverse <- tableToTree(hierWide = copy(Hier.new),levelNames)
testReverse$Parent <- ifelse(testReverse$Parent == 1, "", testReverse$Parent)
fwrite(testReverse, "./outputs/CoastForestHierarchyTree2.csv")


```

Build groups iteratively merging pairs of units with the minimum distance (and <.20) and add an assoc column to SU table for each of the site series in the pair with an assoc number. Then recalculating veg_anal from the list of units a Set all site series to equivalent plot numbers. And iterate.
```{r novel grouping method}
# xx <- test_jac.list[ , .SD[which.min(dist)], by = iso2] %>% filter(dist < 0.2) %>% arrange(iso1)
# unit_list <- unique(xx$iso1) %>% data.frame
# xx[, ID := sequence(.N), by = iso1]
# xx[, change := shift(iso1) != iso1]
# xx[is.na(change), change := TRUE]
# xx[, res := cumsum(change)]
# 
# xx1 <- xx %>% dplyr::select(iso1, res) %>% rename(SiteUnit = 1) %>% distinct
# xx2 <- xx %>% dplyr::select(iso2, res) %>% rename(SiteUnit = 1) %>% distinct
# xx_all <- rbind(xx1, xx2)
```


